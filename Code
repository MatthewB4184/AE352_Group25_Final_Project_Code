import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

m = 1.688  # kg
l = 0.25   # m 
rho = 1.225
kT = 4.7e-5   # N·s^2 / rad^2
kQ = 4.6e-6   # N·m·s^2 / rad^2
g = 9.81

m_r = 0.235  # rotor+motor+prop+ESC mass at each arm (kg)
m_c = 0.734  # central mass (kg)
l_b = 0.29   # body plate length (m)
w = 0.18     # body plate width (m)
h = 0.02     # assumed plate thickness (m)

I_x = 1/12 * m_c * (h**2 + w**2) + 2 * m_r * l**2
I_y = 1/12 * m_c * (h**2 + l_b**2) + 2 * m_r * l**2
I_z = 1/12 * m_c * (l_b**2 + w**2) + 4 * m_r * l**2
I = np.diag([I_x, I_y, I_z])

M = np.array([
    [kT,    kT,    kT,    kT],
    [0.0,  l*kT,  0.0, -l*kT],
    [-l*kT, 0.0,  l*kT,  0.0],
    [kQ,   -kQ,   kQ,   -kQ]
])
Minv = np.linalg.inv(M)

omega_h = 296.0  

Kp_pos = np.array([3.0, 3.0, 6.0])
Kd_pos = np.array([2.0, 2.0, 4.0])
Kp_att = np.array([8.0, 8.0, 4.0])
Kd_att = np.array([2.5, 2.5, 1.2])


omega_max = 4000.0 
T_max = kT * 4 * omega_max**2
tau_max = np.array([0.8, 0.8, 0.5])

def euler_to_R(phi, theta, psi):
    sp = np.sin(phi); cp = np.cos(phi)
    st = np.sin(theta); ct = np.cos(theta)
    ss = np.sin(psi); cs = np.cos(psi)
    R = np.array([
        [ct*cs, cp*ss + sp*st*cs, sp*ss - cp*st*cs],
        [ct*ss, cp*cs - sp*st*ss, sp*cs + cp*st*ss],
        [-st,   sp*ct,             cp*ct]
    ])
    return R


def body_rates_to_euler_dot(phi, theta, p, q, r):
    s_phi = np.sin(phi); c_phi = np.cos(phi)
    c_theta = np.cos(theta)
    # protect cos(theta) near zero
    if abs(c_theta) < 1e-6:
        c_theta = 1e-6 * np.sign(c_theta) if c_theta != 0 else 1e-6
    W = np.array([
        [1, s_phi*np.tan(theta), c_phi*np.tan(theta)],
        [0, c_phi, -s_phi],
        [0, s_phi/c_theta, c_phi/c_theta]
    ])
    return W @ np.array([p, q, r])


def clamp(x, low, high):
    return np.minimum(np.maximum(x, low), high)


def solve_omegas_from_forces(desired_vec):
    s = Minv @ desired_vec
    # numerical safety
    s = np.real(s)
    s = np.clip(s, 1e-8, omega_max**2)
    omegas = np.sqrt(s)
    return omegas, s


def motor_power_from_omegas(omegas):
    return kQ * omegas**3

def cubic_trajectory(p0, p1, T, tau):
    if T <= 0:
        return np.array(p1), np.zeros_like(p1), np.zeros_like(p1)
    s = np.clip(tau / T, 0.0, 1.0)
    s2 = s*s; s3 = s2*s
    pos = p0 + (p1 - p0) * (3*s2 - 2*s3)
    vel = (p1 - p0) * (6*s*(1 - s)) / T
    acc = (p1 - p0) * (6*(1 - 2*s)) / (T*T)
    return pos, vel, acc

def make_maneuver_controller(maneuver):
    if maneuver == 'hover':
        pos_target = np.array([0.0, 0.0, 1.0])
        vel_target = np.zeros(3); acc_target = np.zeros(3)
        def ctrl(s, t):
            return {'pos_des': pos_target, 'vel_des': vel_target, 'acc_des': acc_target, 'psi_des': 0.0, 'yaw_rate_des': 0.0}
        return ctrl, 120.0, 0.02

    if maneuver == 'circle':
        Rcirc = 2.0; v = 0.5; omega_ang = v/Rcirc; duration = 60.0
        def ctrl(s, t):
            theta = omega_ang * t
            pos_des = np.array([Rcirc*np.cos(theta), Rcirc*np.sin(theta), 1.0])
            vel_des = np.array([-Rcirc*omega_ang*np.sin(theta), Rcirc*omega_ang*np.cos(theta), 0.0])
            acc_des = np.array([-Rcirc*(omega_ang**2)*np.cos(theta), -Rcirc*(omega_ang**2)*np.sin(theta), 0.0])
            psi_des = theta + np.pi/2
            return {'pos_des': pos_des, 'vel_des': vel_des, 'acc_des': acc_des, 'psi_des': psi_des, 'yaw_rate_des': omega_ang}
        return ctrl, duration, 0.02

    if maneuver == 'complex':
        t_takeoff = 2.0       
        t_trans1 = 5.0        
        t_hover1 = 2.0
        t_yaw = 3.0          
        t_trans2 = 5.0      
        t_hover2 = 2.0
        t_land = 4.0          
        total = t_takeoff + t_trans1 + t_hover1 + t_yaw + t_trans2 + t_hover2 + t_land

        p_takeoff_start = np.array([0.0, 0.0, 0.0])
        p_takeoff_end = np.array([0.0, 0.0, 1.0])
        p_trans1_start = p_takeoff_end
        p_trans1_end = np.array([5.0, 0.0, 1.0])
        p_trans2_start = p_trans1_end
        p_trans2_end = np.array([5.0, 5.0, 1.0])
        p_land_end = np.array([5.0, 5.0, 0.0])

        yaw_start = 0.0
        yaw_final = np.deg2rad(90.0)  

        def ctrl(s, t):
            pos_des = p_takeoff_end.copy()
            vel_des = np.zeros(3)
            acc_des = np.zeros(3)
            psi_des = yaw_start
            yaw_rate = 0.0

            if t < t_takeoff:
                tau = t
                pos_des, vel_des, acc_des = cubic_trajectory(p_takeoff_start, p_takeoff_end, t_takeoff, tau)
                psi_des = yaw_start
                yaw_rate = 0.0

            elif t < t_takeoff + t_trans1:
                tau = t - t_takeoff
                pos_des, vel_des, acc_des = cubic_trajectory(p_trans1_start, p_trans1_end, t_trans1, tau)
                psi_des = yaw_start
                yaw_rate = 0.0

            elif t < t_takeoff + t_trans1 + t_hover1:
                pos_des = p_trans1_end.copy()
                vel_des = np.zeros(3)
                acc_des = np.zeros(3)
                psi_des = yaw_start
                yaw_rate = 0.0

            elif t < t_takeoff + t_trans1 + t_hover1 + t_yaw:
                tau = t - (t_takeoff + t_trans1 + t_hover1)
                psi_pos, psi_vel, psi_acc = cubic_trajectory(np.array([yaw_start]), np.array([yaw_final]), t_yaw, tau)
                psi_des = float(psi_pos[0])
                yaw_rate = float(psi_vel[0])
                pos_des = p_trans1_end.copy()
                vel_des = np.zeros(3)
                acc_des = np.zeros(3)

            elif t < t_takeoff + t_trans1 + t_hover1 + t_yaw + t_trans2:
                tau = t - (t_takeoff + t_trans1 + t_hover1 + t_yaw)
                pos_des, vel_des, acc_des = cubic_trajectory(p_trans2_start, p_trans2_end, t_trans2, tau)
                psi_des = yaw_final
                yaw_rate = 0.0

            elif t < t_takeoff + t_trans1 + t_hover1 + t_yaw + t_trans2 + t_hover2:
                pos_des = p_trans2_end.copy()
                vel_des = np.zeros(3)
                acc_des = np.zeros(3)
                psi_des = yaw_final
                yaw_rate = 0.0

            else:
                tau = t - (t_takeoff + t_trans1 + t_hover1 + t_yaw + t_trans2 + t_hover2)
                pos_des, vel_des, acc_des = cubic_trajectory(p_trans2_end, p_land_end, t_land, tau)
                psi_des = yaw_final
                yaw_rate = 0.0

            return {
                'pos_des': pos_des,
                'vel_des': vel_des,
                'acc_des': acc_des,
                'psi_des': psi_des,
                'yaw_rate_des': yaw_rate
            }

        return ctrl, total, 0.02

    raise ValueError(f"Unknown maneuver: {maneuver}")

def run_maneuver(name):
    ctrl, duration, dt = make_maneuver_controller(name)
    steps = int(np.ceil(duration / dt)) + 1
    if name == 'hover':
        s = np.array([0.0, 0.0, 1.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0])
    else:
        s = np.array([0.0, 0.0, 0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0])

    history = np.zeros((steps, 12))
    omegas_hist = np.zeros((steps, 4))
    power_hist = np.zeros(steps)
    t_hist = np.zeros(steps)

    for i in range(steps):
        t = i * dt
        history[i, :] = s
        x,y,z, vx,vy,vz, phi,theta,psi, p,q,r = s

        info = ctrl(s, t)
        pos_des = info['pos_des']; vel_des = info['vel_des']; acc_des = info['acc_des']
        psi_des = info['psi_des']; yaw_rate_des = info['yaw_rate_des']

        a_track = acc_des + Kp_pos * (pos_des - np.array([x,y,z])) + Kd_pos * (vel_des - np.array([vx,vy,vz]))
        a_track = np.clip(a_track, -6.0, 6.0)  
        
        T_req = m * (g + a_track[2])
        T_req = float(clamp(T_req, 0.0, T_max))

        phi_des = (a_track[0] * np.sin(psi_des) - a_track[1] * np.cos(psi_des)) / g
        theta_des = (a_track[0] * np.cos(psi_des) + a_track[1] * np.sin(psi_des)) / g

        ang_err = np.array([phi_des - phi, theta_des - theta, (psi_des - psi)])
        rates_des = np.array([0.0, 0.0, yaw_rate_des])
        rates_err = rates_des - np.array([p,q,r])

        tau = Kp_att * ang_err + Kd_att * rates_err
        tau = np.clip(tau, -tau_max, tau_max)

        desired_vec = np.array([T_req, tau[0], tau[1], tau[2]])
        omegas, s_sq = solve_omegas_from_forces(desired_vec)
        power = motor_power_from_omegas(omegas).sum()

        vx_new = vx + a_track[0] * dt
        vy_new = vy + a_track[1] * dt
        vz_new = vz + a_track[2] * dt
        x_new = x + vx_new * dt
        y_new = y + vy_new * dt
        z_new = z + vz_new * dt

        omega_vec = np.array([p,q,r])
        omega_dot = np.linalg.inv(I) @ (np.array([tau[0], tau[1], tau[2]]) - np.cross(omega_vec, I @ omega_vec))
        p_new = p + omega_dot[0] * dt
        q_new = q + omega_dot[1] * dt
        r_new = r + omega_dot[2] * dt

        euler_dot = body_rates_to_euler_dot(phi, theta, p, q, r)
        phi_new = phi + euler_dot[0] * dt
        theta_new = theta + euler_dot[1] * dt
        psi_new = psi + euler_dot[2] * dt

        s = np.array([x_new, y_new, z_new, vx_new, vy_new, vz_new, phi_new, theta_new, psi_new, p_new, q_new, r_new])

        omegas_hist[i, :] = omegas
        power_hist[i] = power
        t_hist[i] = t

    return {'t': t_hist, 'state': history, 'omegas': omegas_hist, 'power': power_hist, 'dt': dt}

def moving_average(arr, window=5):
    if window <= 1:
        return arr
    s = pd.Series(arr)
    return s.rolling(window=window, center=True, min_periods=1).mean().to_numpy()

def plot_and_show(res, title_prefix):
    t = res['t']; st = res['state']; omegas = res['omegas']; power = res['power']
    x = st[:,0]; y = st[:,1]; z = st[:,2]
    phi = st[:,6]; theta = st[:,7]; psi = st[:,8]
    p = st[:,9]; q = st[:,10]; r = st[:,11]

    # 3D trajectory
    fig = plt.figure(figsize=(8,5))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(x, y, z, linewidth=2)
    ax.set_xlabel('X (m)'); ax.set_ylabel('Y (m)'); ax.set_zlabel('Z (m)')
    ax.set_title(f"{title_prefix} - 3D Trajectory")
    plt.tight_layout()
    plt.show()

    # Euler angles
    plt.figure(figsize=(8,3))
    plt.plot(t, phi, label='phi (roll)'); plt.plot(t, theta, label='theta (pitch)'); plt.plot(t, psi, label='psi (yaw)')
    plt.xlabel('Time (s)'); plt.ylabel('Angle (rad)'); plt.title(f"{title_prefix} - Euler Angles"); plt.legend(); plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Body rates
    plt.figure(figsize=(8,3))
    plt.plot(t, p, label='p'); plt.plot(t, q, label='q'); plt.plot(t, r, label='r')
    plt.xlabel('Time (s)'); plt.ylabel('Body rates (rad/s)'); plt.title(f"{title_prefix} - Body Rates"); plt.legend(); plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Rotor speeds 
    omegas_smooth = np.column_stack([moving_average(omegas[:,i], window=7) for i in range(4)])
    plt.figure(figsize=(8,3))
    plt.plot(t, omegas_smooth[:,0], label='omega1'); plt.plot(t, omegas_smooth[:,1], label='omega2')
    plt.plot(t, omegas_smooth[:,2], label='omega3'); plt.plot(t, omegas_smooth[:,3], label='omega4')
    plt.xlabel('Time (s)'); plt.ylabel('Rotor speed (rad/s)'); plt.title(f"{title_prefix} - Rotor Speeds (smoothed)"); plt.legend(); plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Power draw 
    power_smooth = moving_average(power, window=7)
    plt.figure(figsize=(8,3))
    plt.plot(t, power_smooth, linewidth=1.5)
    plt.xlabel('Time (s)'); plt.ylabel('Power (W)'); plt.title(f"{title_prefix} - Total Power Draw (smoothed)"); plt.grid(True)
    plt.tight_layout()
    plt.show()

def main():
    maneuvers = ['hover', 'circle', 'complex']
    results = {}
    for mname in maneuvers:
        print(f"Simulating {mname}...")
        res = run_maneuver(mname)
        results[mname] = res
        plot_and_show(res, mname.capitalize() + ' Maneuver')

    rows = []
    for mname, res in results.items():
        st = res['state']; omegas = res['omegas']; power = res['power']
        final_pos = st[-1, 0:3].tolist()
        max_power = float(np.nanmax(power))
        avg_power = float(np.nanmean(power))
        max_omega = float(np.nanmax(omegas))
        rows.append({'Maneuver': mname, 'Final Position (m)': final_pos, 'Max Power (W)': max_power, 'Avg Power (W)': avg_power, 'Max Omega (rad/s)': max_omega})

    df = pd.DataFrame(rows)
    print('\nSimulation summary:')
    print(df.to_string(index=False))

if __name__ == '__main__':
    main()
